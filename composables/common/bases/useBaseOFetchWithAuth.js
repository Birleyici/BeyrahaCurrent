import { defu } from 'defu'
import { useErrorHandler } from '~/composables/useErrorHandler'

let isRefreshing = false
let currentRefreshToken = null
let refreshSubscribers = []
let refreshAttempts = 0
const MAX_REFRESH_ATTEMPTS = 3
const REFRESH_COOLDOWN = 5000 // 5 saniye

function addRefreshSubscriber(callback) {
  refreshSubscribers.push(callback)
}

function onRefreshed(token) {
  refreshSubscribers.map(callback => callback(token))
  refreshSubscribers = []
}

export async function useBaseOFetchWithAuth(url, options = {}) {
  const authStore = useAuthStore()
  const apiBaseUrl = useBaseUrl()
  const route = useRoute()
  const router = useRouter()

  const headers = {}

  // Authorization ba≈ülƒ±ƒüƒ±nƒ± ekleme
  if (authStore.token) {
    headers['Authorization'] = `Bearer ${authStore.token}`
  }

  // Anonim kullanƒ±cƒ± ID'si varsa, ba≈ülƒ±ƒüa ekle
  if (authStore.anon.id) {
    headers['X-Anonymous-User-ID'] = parseInt(authStore.anon.id, 10)
  }

  const defaults = {
    baseURL: apiBaseUrl,
    headers
  }

  const params = defu(defaults, options)

  try {
    let response = await $fetch(apiBaseUrl + url, params)

    // Anonim kullanƒ±cƒ± ID'si d√∂nd√ºyse, bunu kaydet
    if (response.anonymous_user_id) {
      authStore.anon.id = response.anonymous_user_id
      authStore.anon.name = response.name

      // Headers g√ºncelle ve isteƒüi tekrar yap
      params.headers['X-Anonymous-User-ID'] = response.anonymous_user_id
      response = await $fetch(apiBaseUrl + url, params)
    }

    // Refresh attempt sayacƒ±nƒ± sƒ±fƒ±rla ba≈üarƒ±lƒ± istek sonrasƒ±
    refreshAttempts = 0
    return response

  } catch (error) {
    console.error('useBaseOFetchWithAuth error:', error)

    // 401 Unauthorized hatasƒ± kontrol√º
    if (error.response && error.response.status === 401) {
      const errorData = error.response._data

      // Backend'den gelen hata tipine g√∂re i≈ülem yap
      if (errorData && errorData.requires_login) {
        console.log('Login required, error:', errorData.error)
        
        // Token expired durumu i√ßin refresh dene
        if (errorData.error === 'TOKEN_EXPIRED') {
          return await handleTokenRefresh(authStore, apiBaseUrl, route, router, url, params)
        } else if (['TOKEN_INVALID', 'TOKEN_ERROR', 'USER_NOT_FOUND', 'TOKEN_BLACKLISTED'].includes(errorData.error)) {
          // Bu durumda token tamamen ge√ßersiz, logout yap
          await handleLogout(authStore, router, route, errorData.message)
          throw error
        }
      }

      // Diƒüer 401 durumlarƒ± i√ßin token refresh dene
      return await handleTokenRefresh(authStore, apiBaseUrl, route, router, url, params)
    }

    throw error
  }
}

async function handleTokenRefresh(authStore, apiBaseUrl, route, router, originalUrl, originalParams) {
  const currentToken = authStore.token

  // Refresh cooldown kontrol√º
  const now = Date.now()
  if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
    const timeSinceLastAttempt = now - (refreshAttempts * REFRESH_COOLDOWN)
    if (timeSinceLastAttempt < REFRESH_COOLDOWN) {
      console.log('Refresh cooldown active, forcing logout')
      await handleLogout(authStore, router, route, '√áok fazla refresh denemesi. L√ºtfen tekrar giri≈ü yapƒ±n.')
      throw new Error('Refresh cooldown active')
    } else {
      // Cooldown s√ºresi ge√ßti, sayacƒ± sƒ±fƒ±rla
      refreshAttempts = 0
    }
  }

  // Eƒüer aynƒ± token ile refresh i≈ülemi devam ediyorsa, bekle
  if (isRefreshing && currentRefreshToken === currentToken) {
    console.log('Token refresh already in progress for current token, waiting...')
    return new Promise((resolve, reject) => {
      addRefreshSubscriber((token) => {
        if (token) {
          // Yeni token ile original isteƒüi tekrar yap
          originalParams.headers['Authorization'] = `Bearer ${token}`
          $fetch(apiBaseUrl + originalUrl, originalParams)
            .then(resolve)
            .catch(reject)
        } else {
          reject(new Error('Token refresh failed'))
        }
      })
    })
  }

  // Eƒüer farklƒ± bir token ile refresh devam ediyorsa, iptal et
  if (isRefreshing && currentRefreshToken !== currentToken) {
    console.log('Different token refresh in progress, cancelling current request')
    throw new Error('Token changed during refresh')
  }

  isRefreshing = true
  currentRefreshToken = currentToken
  refreshAttempts++

  try {
    console.log(`Attempting token refresh (attempt ${refreshAttempts}/${MAX_REFRESH_ATTEMPTS})...`)
    
    const response = await $fetch(apiBaseUrl + 'auth/refresh', {
      method: 'POST',
      headers: { Authorization: `Bearer ${currentToken}` }
    })

    if (response && response.token) {
      // Token ba≈üarƒ±yla yenilendi
      authStore.token = response.token
      
      // User bilgisi de geldiyse g√ºncelle
      if (response.user) {
        authStore.currentUser = response.user
      }

      console.log('Token refreshed successfully')
      refreshAttempts = 0 // Ba≈üarƒ±lƒ± refresh sonrasƒ± sayacƒ± sƒ±fƒ±rla
      onRefreshed(response.token)

      // Original isteƒüi yeni token ile tekrar yap
      originalParams.headers['Authorization'] = `Bearer ${response.token}`
      const retryResponse = await $fetch(apiBaseUrl + originalUrl, originalParams)
      
      return retryResponse

    } else {
      throw new Error('Token refresh failed - no token returned')
    }

  } catch (error) {
    console.error(`Token refresh failed (attempt ${refreshAttempts}/${MAX_REFRESH_ATTEMPTS}):`, error)
    
    // Max deneme sayƒ±sƒ±na ula≈ütƒ±ysak logout yap
    if (refreshAttempts >= MAX_REFRESH_ATTEMPTS) {
      console.log('Max refresh attempts reached, forcing logout')
      let errorMessage = 'Oturum yenileme ba≈üarƒ±sƒ±z. L√ºtfen tekrar giri≈ü yapƒ±n.'
      
      if (error.response && error.response._data) {
        const errorData = error.response._data
        if (errorData.message) {
          errorMessage = errorData.message
        }
        
        // Backend'den gelen spesifik hatalar
        if (['TOKEN_BLACKLISTED', 'TOKEN_INVALID', 'TOKEN_EXPIRED'].includes(errorData.error)) {
          errorMessage = errorData.message || 'Oturum ge√ßersiz. L√ºtfen tekrar giri≈ü yapƒ±n.'
        }
      }

      await handleLogout(authStore, router, route, errorMessage)
      onRefreshed(null) // Bekleyen isteklere null g√∂nder
    }
    
    throw error
  } finally {
    isRefreshing = false
    currentRefreshToken = null
  }
}

async function handleLogout(authStore, router, route, errorMessage = null) {
  try {
    console.log('üö® HANDLE LOGOUT CALLED üö®')
    console.log('Error message:', errorMessage)
    console.log('Current route:', route?.fullPath)
    console.log('Router available:', !!router)
    
    // Timer'larƒ± durdur
    if (authStore.clearTokenRefreshTimer) {
      authStore.clearTokenRefreshTimer()
    }
    
    // Store'u temizle
    authStore.token = null
    authStore.currentUser = null
    
    // MANUEL LOCALSTORAGE TEMƒ∞ZLEME - Pinia persist otomatik yapmƒ±yor
    if (process.client) {
      try {
        localStorage.removeItem('authStore')
        // T√ºm auth ile ilgili localStorage items'larƒ± temizle
        Object.keys(localStorage).forEach(key => {
          if (key.includes('auth') || key.includes('token') || key.includes('user')) {
            localStorage.removeItem(key)
          }
        })
        console.log('üßπ localStorage authStore cleared manually in handleLogout')
      } catch (e) {
        console.warn('Failed to clear localStorage in handleLogout:', e)
      }
    }
    
    // Logout actions
    if (authStore.actionsOnLogout) {
      await authStore.actionsOnLogout()
    }
    
    // Error message varsa toast g√∂ster (eƒüer toast sistemi varsa)
    if (errorMessage && process.client) {
      // Toast sistemini kontrol et
      try {
        const { $toast } = useNuxtApp()
        if ($toast) {
          $toast.error(errorMessage)
        }
      } catch (e) {
        console.warn('Toast system not available:', e)
      }
    }

    // Y√∂nlendirme mantƒ±ƒüƒ± - Management vs Normal area
    const currentPath = route.fullPath
    console.log('üîç Determining redirect path for:', currentPath)
    
    // Management alanƒ±nda ise callback ile current path'i ekleyerek management/login'e y√∂nlendir
    if (currentPath.startsWith('/management')) {
      const redirectPath = `/management/login?callback=${encodeURIComponent(currentPath)}`
      console.log('üöÄ Management area - redirecting to:', redirectPath)
      await router.push(redirectPath)
    } else {
      // Normal alanda ise - sadece protected route'larda y√∂nlendir
      const protectedRoutes = ['/hesap']
      const isOnProtectedRoute = protectedRoutes.some(route => currentPath.startsWith(route))
      
      if (isOnProtectedRoute) {
        const redirectPath = `/auth?callback=${encodeURIComponent(currentPath)}`
        console.log('üöÄ Protected route - redirecting to:', redirectPath)
        await router.push(redirectPath)
      } else {
        console.log('üè† Non-protected route - staying on current page')
        // Protected olmayan sayfalarda y√∂nlendirme yapmƒ±yoruz
      }
    }
    
    console.log('‚úÖ Redirect completed successfully')
    
  } catch (error) {
    console.error('‚ùå Error during logout handling:', error)
    
    // En son √ßare olarak sayfa yenile
    if (process.client) {
      console.log('üîÑ Fallback: redirecting via window.location')
      // LocalStorage'ƒ± da temizle
      try {
        localStorage.removeItem('authStore')
        // T√ºm auth ile ilgili localStorage items'larƒ± temizle
        Object.keys(localStorage).forEach(key => {
          if (key.includes('auth') || key.includes('token') || key.includes('user')) {
            localStorage.removeItem(key)
          }
        })
      } catch (e) {
        console.warn('Failed to clear localStorage in fallback:', e)
      }
      
      // Current path'e g√∂re fallback redirect
      const currentPath = route.fullPath
      if (currentPath.startsWith('/management')) {
        window.location.href = '/management/login'
      } else {
        const protectedRoutes = ['/hesap']
        const isOnProtectedRoute = protectedRoutes.some(route => currentPath.startsWith(route))
        
        if (isOnProtectedRoute) {
          window.location.href = '/auth'
        }
        // Non-protected route'larda sayfa yenileme yapmƒ±yoruz
      }
    }
  }
}

// Export for use in other composables
export { handleLogout }
